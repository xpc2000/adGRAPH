/******************************************************************************
 * Copyright (c) 2011, Duane Merrill.  All rights reserved.
 * Copyright (c) 2011-2017, NVIDIA CORPORATION.  All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the NVIDIA CORPORATION nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL NVIDIA CORPORATION BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 ******************************************************************************/

/**
 * \file
 * Common type manipulation (metaprogramming) utilities
 */

#pragma once

#include <iostream>
#include <limits>
#include <cfloat>

//#include "util_macro.cuh"
//#include "util_arch.cuh"
//#include "util_namespace.cuh"

#include "cuComplex.h"

/// nvgraph namespace
namespace nvgraph {

/**
 * \addtogroup UtilModule
 * @{
 */

#ifndef CUB_MAX
    /// Select maximum(a, b)
    #define CUB_MAX(a, b) (((b) > (a)) ? (b) : (a))
#endif

#ifndef CUB_MIN
    /// Select minimum(a, b)
    #define CUB_MIN(a, b) (((b) < (a)) ? (b) : (a))
#endif
 
template <typename _T>
struct FpLimits;

template <>
template <>
struct FpLimits<float>
{
    static __host__ __device__ __forceinline__ float Max() {
        return FLT_MAX;
    }

    static __host__ __device__ __forceinline__ float Lowest() {
        return FLT_MAX * float(-1);
    }
};

template <>
struct FpLimits<double>
{
    static __host__ __device__ __forceinline__ double Max() {
        return DBL_MAX;
    }

    static __host__ __device__ __forceinline__ double Lowest() {
        return DBL_MAX  * double(-1);
    }
};

template <typename _T>
struct TypeConst;

template <>
struct TypeConst<cuComplex>
{
    static __host__ __device__ __forceinline__ cuComplex Zero()
    {
        return make_cuComplex(0.f, 0.f);
    }
    static __host__ __device__ __forceinline__ cuComplex One()
    {
        return make_cuComplex(1.f, 0.f);
    }
};

template <>
struct TypeConst<cuDoubleComplex>
{
    static __host__ __device__ __forceinline__ cuDoubleComplex Zero()
    {
        return make_cuDoubleComplex(0.f, 0.f);
    }
    static __host__ __device__ __forceinline__ cuDoubleComplex One()
    {
        return make_cuDoubleComplex(1.f, 0.f);
    }
};

template <typename _T>
struct TypeConst
{
    static __host__ __device__ __forceinline__ _T Zero()
    {
        return _T(0);
    }
    static __host__ __device__ __forceinline__ _T One()
    {
        return _T(1);
    }
};



template<typename V>
struct PlusTimesSemiring
{
    // enable with c++11
    /*
    static_assert(  std::is_same<float, typename std::remove_cv<V>::type>::value  ||
                    std::is_same<double, typename std::remove_cv<T>::type>::value,
                    "Graph value type is not supported by this semiring");
    */

    static __host__ __device__ __forceinline__ V plus_ident(){ return TypeConst<V>::Zero();}
    static __host__ __device__ __forceinline__ V times_ident(){ return TypeConst<V>::One();}
    static __host__ __device__ __forceinline__ V times_null(){ return TypeConst<V>::Zero();}


    static __host__ __device__ __forceinline__ V plus(const V &arg0, const V &arg1)
    {
        return arg0 + arg1;
    }
    static __host__ __device__ __forceinline__ V times(const V &arg0, const V &arg1)
    {
        return arg0 * arg1;
    }

    // used in external algs
    struct SumOp
    {
        /// Boolean sum operator, returns <tt>a + b</tt>
        template <typename T>
        __host__ __device__ __forceinline__ T operator()(const T &a, const T &b) const
        {
            return plus(a, b);
        }
    };

    enum{
        HAS_PLUS_ATOMICS = 1, // for cub fixup path deduction
    };
};

template<typename V>
struct MinPlusSemiring
{
    // enable with c++11
    /*
    static_assert(  std::is_same<float, typename std::remove_cv<V>::type>::value  ||
                    std::is_same<double, typename std::remove_cv<T>::type>::value,
                    "Graph value type is not supported by this semiring");
    */

    static __host__ __device__ __forceinline__ V plus_ident(){ return FpLimits<V>::Max();}
    static __host__ __device__ __forceinline__ V times_ident(){ return TypeConst<V>::Zero();}
    static __host__ __device__ __forceinline__ V times_null(){ return FpLimits<V>::Max();}


    static __host__ __device__ __forceinline__ V plus(const V &arg0, const V &arg1)
    {
        return CUB_MIN(arg0, arg1);
    }
    static __host__ __device__ __forceinline__ V times(const V &arg0, const V &arg1)
    {
        return arg0 + arg1;
    }

    // used in external algs
    struct SumOp
    {
        /// Boolean sum operator, returns <tt>a + b</tt>
        template <typename T>
        __host__ __device__ __forceinline__ T operator()(const T &a, const T &b) const
        {
            return plus(a, b);
        }
    };

    enum{
        HAS_PLUS_ATOMICS = 0, // for cub fixup path deduction
    };
};


template<typename V>
struct MaxMinSemiring
{
    // enable with c++11
    /*
    static_assert(  std::is_same<float, typename std::remove_cv<V>::type>::value  ||
                    std::is_same<double, typename std::remove_cv<T>::type>::value,
                    "Graph value type is not supported by this semiring");
    */

    static __host__ __device__ __forceinline__ V plus_ident(){ return FpLimits<V>::Lowest();}
    static __host__ __device__ __forceinline__ V times_ident(){ return FpLimits<V>::Max();}
    static __host__ __device__ __forceinline__ V times_null(){ return FpLimits<V>::Lowest();}


    static __host__ __device__ __forceinline__ V plus(const V &arg0, const V &arg1)
    {
        return CUB_MAX(arg0, arg1);
    }
    static __host__ __device__ __forceinline__ V times(const V &arg0, const V &arg1)
    {
        return CUB_MIN(arg0, arg1);
    }

    // used in external algs
    struct SumOp
    {
        /// Boolean sum operator, returns <tt>a + b</tt>
        template <typename T>
        __host__ __device__ __forceinline__ T operator()(const T &a, const T &b) const
        {
            return plus(a, b);
        }
    };

    enum{
        HAS_PLUS_ATOMICS = 0, // for cub fixup path deduction
    };
};

template<typename V>
struct OrAndBoolSemiring
{
    // enable with c++11
    /*
    static_assert(  std::is_same<float, typename std::remove_cv<V>::type>::value  ||
                    std::is_same<double, typename std::remove_cv<T>::type>::value,
                    "Graph value type is not supported by this semiring");
    */

    static __host__ __device__ __forceinline__ V plus_ident(){ return TypeConst<V>::Zero();}
    static __host__ __device__ __forceinline__ V times_ident(){ return TypeConst<V>::One();}
    static __host__ __device__ __forceinline__ V times_null(){ return TypeConst<V>::Zero();}


    static __host__ __device__ __forceinline__ V plus(const V &arg0, const V &arg1)
    {
        return (bool) arg0 | (bool) arg1;
    }
    static __host__ __device__ __forceinline__ V times(const V &arg0, const V &arg1)
    {
        return (bool) arg0 & (bool) arg1;
    }

    // used in external algs
    struct SumOp
    {
        /// Boolean sum operator, returns <tt>a + b</tt>
        template <typename T>
        __host__ __device__ __forceinline__ T operator()(const T &a, const T &b) const
        {
            return plus(a, b);
        }
    };

    enum{
        HAS_PLUS_ATOMICS = 0, // for cub fixup path deduction
    };
};


template<typename V>
struct LogPlusSemiring
{
    // enable with c++11
    /*
    static_assert(  std::is_same<float, typename std::remove_cv<V>::type>::value  ||
                    std::is_same<double, typename std::remove_cv<T>::type>::value,
                    "Graph value type is not supported by this semiring");
    */

    static __host__ __device__ __forceinline__ V plus_ident(){ return FpLimits<V>::Max();}
    static __host__ __device__ __forceinline__ V times_ident(){ return TypeConst<V>::Zero();}
    static __host__ __device__ __forceinline__ V times_null(){ return FpLimits<V>::Max();}


    static __host__ __device__ __forceinline__ V plus(const V &arg0, const V &arg1)
    {
        return -log(exp(-arg0) + exp(-arg1));
    }
    static __host__ __device__ __forceinline__ V times(const V &arg0, const V &arg1)
    {
        return arg0 + arg1;
    }

    // used in external algs
    struct SumOp
    {
        /// Boolean sum operator, returns <tt>a + b</tt>
        template <typename T>
        __host__ __device__ __forceinline__ T operator()(const T &a, const T &b) const
        {
            return plus(a, b);
        }
    };

    enum{
        HAS_PLUS_ATOMICS = 0, // for cub fixup path deduction
    };
};

// used in external algs
template <typename SR>
struct SumOp
{
    /// Boolean sum operator, returns <tt>a + b</tt>
    template <typename T>
    __host__ __device__ __forceinline__ T operator()(const T &a, const T &b) const
    {
        return SR::plus(a, b);
    }
};


/** @} */       // end group UtilModule

}               // nvgraph namespace
